# yamllint disable rule:document-start rule:line-length rule:trailing-spaces
suite: Test with custom rules
templates:
  - configmap.yaml
tests:
  - it: should render the default configuration
    set:
      deployAsConfigMap: true
      kube-state-metrics:
        extraDiscoveryRules: |-
          rule {
            action = "labeldrop"
            regex = "source"
          }
        extraMetricProcessingRules: |-
          rule {
            source_labels = ["namespace"]
            regex = "private"
            action = "drop"
          }
      node-exporter:
        extraDiscoveryRules: |-
          rule {
            target_label = "color"
            replacement = "red"
          }
    asserts:
      - isKind:
          of: ConfigMap
      - equal:
          path: data["module.alloy"]
          value: |-
            declare "cluster_metrics" {
              argument "metrics_destinations" {
                comment = "Must be a list of metric destinations where collected metrics should be forwarded to"
              }
              import.git "kubernetes" {
                repository = "https://github.com/grafana/alloy-modules.git"
                revision = "main"
                path = "modules/kubernetes/core/metrics.alloy"
                pull_frequency = "15m"
              }
            
              kubernetes.kubelet "scrape" {
                clustering = true
                keep_metrics = "up|container_cpu_usage_seconds_total|kubelet_certificate_manager_client_expiration_renew_errors|kubelet_certificate_manager_client_ttl_seconds|kubelet_certificate_manager_server_ttl_seconds|kubelet_cgroup_manager_duration_seconds_bucket|kubelet_cgroup_manager_duration_seconds_count|kubelet_node_config_error|kubelet_node_name|kubelet_pleg_relist_duration_seconds_bucket|kubelet_pleg_relist_duration_seconds_count|kubelet_pleg_relist_interval_seconds_bucket|kubelet_pod_start_duration_seconds_bucket|kubelet_pod_start_duration_seconds_count|kubelet_pod_worker_duration_seconds_bucket|kubelet_pod_worker_duration_seconds_count|kubelet_running_container_count|kubelet_running_containers|kubelet_running_pod_count|kubelet_running_pods|kubelet_runtime_operations_errors_total|kubelet_runtime_operations_total|kubelet_server_expiration_renew_errors|kubelet_volume_stats_available_bytes|kubelet_volume_stats_capacity_bytes|kubelet_volume_stats_inodes|kubelet_volume_stats_inodes_used|kubernetes_build_info|namespace_workload_pod|rest_client_requests_total|storage_operation_duration_seconds_count|storage_operation_errors_total|volume_manager_total_volumes"
                scrape_interval = "60s"
                max_cache_size = 100000
                forward_to = argument.metrics_destinations.value
              }
            
              kubernetes.resources "scrape" {
                clustering = true
                job_label = "integrations/kubernetes/resources"
                keep_metrics = "up|node_cpu_usage_seconds_total|node_memory_working_set_bytes"
                scrape_interval = "60s"
                max_cache_size = 100000
                forward_to = argument.metrics_destinations.value
              }
            
              kubernetes.cadvisor "scrape" {
                clustering = true
                keep_metrics = "up|container_cpu_cfs_periods_total|container_cpu_cfs_throttled_periods_total|container_cpu_usage_seconds_total|container_fs_reads_bytes_total|container_fs_reads_total|container_fs_writes_bytes_total|container_fs_writes_total|container_memory_cache|container_memory_rss|container_memory_swap|container_memory_working_set_bytes|container_network_receive_bytes_total|container_network_receive_packets_dropped_total|container_network_receive_packets_total|container_network_transmit_bytes_total|container_network_transmit_packets_dropped_total|container_network_transmit_packets_total|machine_memory_bytes"
                scrape_interval = "60s"
                max_cache_size = 100000
                forward_to = [prometheus.relabel.cadvisor.receiver]
              }
            
              prometheus.relabel "cadvisor" {
                max_cache_size = 100000
                // Drop empty container labels, addressing https://github.com/google/cadvisor/issues/2688
                rule {
                  source_labels = ["__name__","container"]
                  separator = "@"
                  regex = "(container_cpu_.*|container_fs_.*|container_memory_.*)@"
                  action = "drop"
                }
                // Drop empty image labels, addressing https://github.com/google/cadvisor/issues/2688
                rule {
                  source_labels = ["__name__","image"]
                  separator = "@"
                  regex = "(container_cpu_.*|container_fs_.*|container_memory_.*|container_network_.*)@"
                  action = "drop"
                }
                // Normalizing unimportant labels (not deleting to continue satisfying <label>!="" checks)
                rule {
                  source_labels = ["__name__", "boot_id"]
                  separator = "@"
                  regex = "machine_memory_bytes@.*"
                  target_label = "boot_id"
                  replacement = "NA"
                }
                rule {
                  source_labels = ["__name__", "system_uuid"]
                  separator = "@"
                  regex = "machine_memory_bytes@.*"
                  target_label = "system_uuid"
                  replacement = "NA"
                }
                // Filter out non-physical devices/interfaces
                rule {
                  source_labels = ["__name__", "device"]
                  separator = "@"
                  regex = "container_fs_.*@(/dev/)?(mmcblk.p.+|nvme.+|rbd.+|sd.+|vd.+|xvd.+|dasd.+)"
                  target_label = "__keepme"
                  replacement = "1"
                }
                rule {
                  source_labels = ["__name__", "__keepme"]
                  separator = "@"
                  regex = "container_fs_.*@"
                  action = "drop"
                }
                rule {
                  source_labels = ["__name__"]
                  regex = "container_fs_.*"
                  target_label = "__keepme"
                  replacement = ""
                }
                rule {
                  source_labels = ["__name__", "interface"]
                  separator = "@"
                  regex = "container_network_.*@(en[ospx][0-9].*|wlan[0-9].*|eth[0-9].*)"
                  target_label = "__keepme"
                  replacement = "1"
                }
                rule {
                  source_labels = ["__name__", "__keepme"]
                  separator = "@"
                  regex = "container_network_.*@"
                  action = "drop"
                }
                rule {
                  source_labels = ["__name__"]
                  regex = "container_network_.*"
                  target_label = "__keepme"
                  replacement = ""
                }
                forward_to = argument.metrics_destinations.value
              }
            
              import.git "kube_state_metrics" {
                repository = "https://github.com/grafana/alloy-modules.git"
                revision = "main"
                path = "modules/kubernetes/kube-state-metrics/metrics.alloy"
                pull_frequency = "15m"
              }
            
              kube_state_metrics.kubernetes "targets" {
                label_selectors = [
                  "app.kubernetes.io/name=kube-state-metrics",
                  "release=RELEASE-NAME",
                ]
              }
            
              discovery.relabel "kube_state_metrics" {
                targets = kube_state_metrics.kubernetes.targets.output
            
                rule {
                  action = "labeldrop"
                  regex = "source"
                }
              }

              kube_state_metrics.scrape "metrics" {
                targets = discovery.relabel.kube_state_metrics.output
                clustering = true
                keep_metrics = "up|kube_daemonset.*|kube_deployment_metadata_generation|kube_deployment_spec_replicas|kube_deployment_status_observed_generation|kube_deployment_status_replicas_available|kube_deployment_status_replicas_updated|kube_horizontalpodautoscaler_spec_max_replicas|kube_horizontalpodautoscaler_spec_min_replicas|kube_horizontalpodautoscaler_status_current_replicas|kube_horizontalpodautoscaler_status_desired_replicas|kube_job.*|kube_namespace_status_phase|kube_node.*|kube_persistentvolumeclaim_resource_requests_storage_bytes|kube_pod_container_info|kube_pod_container_resource_limits|kube_pod_container_resource_requests|kube_pod_container_status_last_terminated_reason|kube_pod_container_status_restarts_total|kube_pod_container_status_waiting_reason|kube_pod_info|kube_pod_owner|kube_pod_start_time|kube_pod_status_phase|kube_pod_status_reason|kube_replicaset.*|kube_resourcequota|kube_statefulset.*"
                scrape_interval = "60s"
                max_cache_size = 100000
                forward_to = [prometheus.relabel.kube_state_metrics.receiver]
              }
            
              prometheus.relabel "kube_state_metrics" {
                max_cache_size = 100000
            
                rule {
                  source_labels = ["namespace"]
                  regex = "private"
                  action = "drop"
                }
                forward_to = argument.metrics_destinations.value
              }
          
              import.git "node_exporter" {
                repository = "https://github.com/grafana/alloy-modules.git"
                revision = "main"
                path = "modules/system/node-exporter/metrics.alloy"
                pull_frequency = "15m"
              }
            
              node_exporter.kubernetes "targets" {
                label_selectors = [
                  "app.kubernetes.io/name=node-exporter",
                  "release=RELEASE-NAME",
                ]
              }
            
              discovery.relabel "node_exporter" {
                targets = node_exporter.kubernetes.targets.output
                rule {
                  source_labels = ["__meta_kubernetes_pod_node_name"]
                  action = "replace"
                  target_label = "instance"
                }

                rule {
                  target_label = "color"
                  replacement = "red"
                }
              }
            
              node_exporter.scrape "metrics" {
                targets = discovery.relabel.node_exporter.output
                job_label = "integrations/node_exporter"
                clustering = true
                keep_metrics = "up|node_cpu.*|node_exporter_build_info|node_filesystem.*|node_memory.*|node_network_receive_bytes_total|node_network_receive_drop_total|node_network_transmit_bytes_total|node_network_transmit_drop_total|process_cpu_seconds_total|process_resident_memory_bytes"
                scrape_interval = "60s"
                max_cache_size = 100000
                forward_to = argument.metrics_destinations.value
              }
            
              import.git "windows_exporter" {
                repository = "https://github.com/grafana/alloy-modules.git"
                revision = "main"
                path = "modules/system/node-exporter/metrics.alloy"
                pull_frequency = "15m"
              }
            
              windows_exporter.kubernetes "targets" {
                label_selectors = [
                  "app.kubernetes.io/name=windows-exporter",
                  "release=RELEASE-NAME",
                ]
              }
            
              discovery.relabel "windows_exporter" {
                targets = windows_exporter.kubernetes.targets.output
                rule {
                  source_labels = ["__meta_kubernetes_pod_node_name"]
                  action = "replace"
                  target_label = "instance"
                }
              }
            
              windows_exporter.scrape "metrics" {
                targets = discovery.relabel.windows_exporter.output
                clustering = true
                keep_metrics = "up|windows_.*|node_cpu_seconds_total|node_filesystem_size_bytes|node_filesystem_avail_bytes|container_cpu_usage_seconds_total"
                scrape_interval = "60s"
                max_cache_size = 100000
                forward_to = argument.metrics_destinations.value
              }
            }
