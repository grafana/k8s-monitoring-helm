// Feature: Kubernetes Manifests
declare "kubernetes_manifests" {
  argument "logs_destinations" {
    comment = "Must be a list of log destinations where collected logs should be forwarded to"
  }


  otelcol.receiver.filelog "pod_manifests" {
    include = ["/var/kubernetes-manifests/pods/*/*.json"]
    include_file_path_resolved = true
    start_at = "beginning"
    delete_after_read = true

    output {
      logs = [otelcol.processor.transform.pod_manifests.input]
    }
  }

  otelcol.processor.transform "pod_manifests" {
    error_mode = "ignore"

    log_statements {
      context = "log"
      statements = [
        `merge_maps(attributes, ExtractPatterns(log.attributes["log.file.path_resolved"], "^/var/kubernetes-manifests/pods/(?P<namespace>[^/]+)/(?P<pod>[^.]+)\\.json$"), "upsert")`,
        `set(resource.attributes["k8s.namespace.name"], attributes["namespace"])`,
        `set(resource.attributes["k8s.pod.name"], attributes["pod"])`,
        `set(resource.attributes["service.name"], "k8s.grafana.com/manifest-collector")`,
        `set(resource.attributes["service.namespace"], "default")`,
      ]
    }

    output {
      logs = [otelcol.processor.k8sattributes.pod_manifests.input]
    }
  }

  otelcol.processor.k8sattributes "pod_manifests" {
    pod_association {
      source {
        from = "resource_attribute"
        name = "k8s.pod.name"
      }
      source {
        from = "resource_attribute"
        name = "k8s.namespace.name"
      }
    }

    extract {
      metadata = [
        "k8s.cronjob.name",
        "k8s.daemonset.name",
        "k8s.deployment.name",
        "k8s.job.name",
        "k8s.node.name",
        "k8s.pod.start_time",
        "k8s.replicaset.name",
        "k8s.statefulset.name",
      ]
    }

    output {
      logs = argument.logs_destinations.value
    }
  }
}
kubernetes_manifests "feature" {
  logs_destinations = [
    otelcol.exporter.loki.loki.input,
  ]
}




// Destination: loki (loki)
otelcol.exporter.loki "loki" {
  forward_to = [loki.write.loki.receiver]
}

loki.write "loki" {
  endpoint {
    url = "http://loki.loki.svc:3100/loki/api/v1/push"
    retry_on_http_429 = true
    tenant_id = convert.nonsensitive(remote.kubernetes.secret.loki.data["tenantId"])
    basic_auth {
      username = convert.nonsensitive(remote.kubernetes.secret.loki.data["username"])
      password = remote.kubernetes.secret.loki.data["password"]
    }
    tls_config {
      insecure_skip_verify = false
    }
    min_backoff_period = "500ms"
    max_backoff_period = "5m"
    max_backoff_retries = "10"
  }
  external_labels = {
    "cluster" = "kubernetes-manifest-cluster",
    "k8s_cluster_name" = "kubernetes-manifest-cluster",
  }
}

remote.kubernetes.secret "loki" {
  name      = "loki-k8smon-k8s-monitoring"
  namespace = "default"
}

