// Feature: PodLogs Objects
declare "pod_logs_objects" {
  argument "logs_destinations" {
    comment = "Must be a list of log destinations where collected logs should be forwarded to"
  }


  loki.source.podlogs "default" {
    preserve_discovered_labels = true
    tail_from_end = false

    clustering {
      enabled = true
    }
    forward_to = [loki.relabel.pod_logs_objects.receiver]
  }


  loki.relabel "pod_logs_objects" {
    rule {
      source_labels = ["__meta_kubernetes_pod_node_name"]
      target_label = "node"
    }
    rule {
      source_labels = ["__meta_kubernetes_namespace"]
      target_label = "namespace"
    }
    rule {
      source_labels = ["__meta_kubernetes_pod_name"]
      target_label = "pod"
    }
    rule {
      source_labels = ["__meta_kubernetes_pod_container_name"]
      target_label = "container"
    }

    forward_to = [loki.process.pod_logs_objects.receiver]
  }

  loki.process "pod_logs_objects" {
    stage.match {
      selector = "{tmp_container_runtime=~\"containerd|cri-o\"}"
      // the cri processing stage extracts the following k/v pairs: log, stream, time, flags
      stage.cri {}

      // Set the extract flags and stream values as labels
      stage.labels {
        values = {
          flags  = "",
          stream  = "",
        }
      }
    }

    stage.match {
      selector = "{tmp_container_runtime=\"docker\"}"
      // the docker processing stage extracts the following k/v pairs: log, stream, time
      stage.docker {}

      // Set the extract stream value as a label
      stage.labels {
        values = {
          stream  = "",
        }
      }
    }

    // Drop the filename label, since it's not really useful in the context of Kubernetes, where we already have cluster,
    // namespace, pod, and container labels. Drop any structured metadata. Also drop the temporary
    // container runtime label as it is no longer needed.
    stage.label_drop {
      values = [
        "filename",
        "tmp_container_runtime",
      ]
    }
    stage.structured_metadata {
      values = {
        "k8s_pod_name" = "k8s_pod_name",
        "pod" = "pod",
        "service_instance_id" = "service_instance_id",
      }
    }


    forward_to = argument.logs_destinations.value
  }
}
pod_logs_objects "feature" {
  logs_destinations = [
    loki.write.loki.receiver,
  ]
}

livedebugging {
  enabled = true
}


// Destination: loki (loki)
otelcol.exporter.loki "loki" {
  forward_to = [loki.write.loki.receiver]
}

loki.write "loki" {
  endpoint {
    url = "http://loki.loki.svc:3100/loki/api/v1/push"
    retry_on_http_429 = true
    tenant_id = convert.nonsensitive(remote.kubernetes.secret.loki.data["tenantId"])
    basic_auth {
      username = convert.nonsensitive(remote.kubernetes.secret.loki.data["username"])
      password = remote.kubernetes.secret.loki.data["password"]
    }
    tls_config {
      insecure_skip_verify = false
    }
    min_backoff_period = "500ms"
    max_backoff_period = "5m"
    max_backoff_retries = "10"
  }
  external_labels = {
    "cluster" = "pod-logs-objects-cluster",
    "k8s_cluster_name" = "pod-logs-objects-cluster",
  }
}

remote.kubernetes.secret "loki" {
  name      = "loki-k8smon-k8s-monitoring"
  namespace = "default"
}

