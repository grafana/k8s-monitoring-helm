creates an always_sample policy:
  1: |
    apiVersion: collectors.grafana.com/v1alpha1
    kind: Alloy
    metadata:
      name: RELEASE-NAME-tempo-sampler
      namespace: NAMESPACE
    spec:
      alloy:
        configMap:
          content: "otelcol.receiver.otlp \"receiver\" {\n  grpc {\n    max_recv_msg_size = \"4MB\"  # TODO this could be configurable\"\n  }\n\n  output {\n    traces = [\"otelcol.processor.tail_sampling.sampler.input\"]\n  }\n}\n\notelcol.processor.tail_sampling \"sampler\" {\n  // https://grafana.com/docs/alloy/latest/reference/components/otelcol.processor.tail_sampling/\n\n  decision_wait = \"15s\"\n\n  \n\n  output {\n    traces = [otelcol.processor.batch.default.input]\n  }\n}\n\n// Destination: tempo (otlp)\notelcol.receiver.prometheus \"tempo\" {\n  output {\n    metrics = [otelcol.processor.attributes.tempo.input]\n  }\n}\notelcol.receiver.loki \"tempo\" {\n  output {\n    logs = [otelcol.processor.attributes.tempo.input]\n  }\n}\n\notelcol.processor.attributes \"tempo\" {\n  output {\n    metrics = [otelcol.processor.transform.tempo.input]\n    logs = [otelcol.processor.transform.tempo.input]\n    traces = [otelcol.processor.transform.tempo.input]\n  }\n}\n\notelcol.processor.transform \"tempo\" {\n  error_mode = \"ignore\"\n  metric_statements {\n    context = \"resource\"\n    statements = [\n      `set(attributes[\"cluster\"], \"\")`,\n      `set(attributes[\"k8s.cluster.name\"], \"\")`,\n    ]\n  }\n\n  metric_statements {\n    context = \"datapoint\"\n    statements = [\n      `set(attributes[\"cluster\"], \"\")`,\n      `set(attributes[\"k8s.cluster.name\"], \"\")`,\n      `set(resource.attributes[\"deployment.environment\"], attributes[\"deployment_environment\"] ) where resource.attributes[\"deployment.environment\"] == nil and attributes[\"deployment_environment\"] != nil`,\n      `delete_key(attributes, \"deployment_environment\") where attributes[\"deployment_environment\"] == resource.attributes[\"deployment.environment\"]`,\n      `set(resource.attributes[\"deployment.environment.name\"], attributes[\"deployment_environment_name\"] ) where resource.attributes[\"deployment.environment.name\"] == nil and attributes[\"deployment_environment_name\"] != nil`,\n      `delete_key(attributes, \"deployment_environment_name\") where attributes[\"deployment_environment_name\"] == resource.attributes[\"deployment.environment.name\"]`,\n      `set(resource.attributes[\"service.name\"], attributes[\"service_name\"] ) where resource.attributes[\"service.name\"] == nil and attributes[\"service_name\"] != nil`,\n      `delete_key(attributes, \"service_name\") where attributes[\"service_name\"] == resource.attributes[\"service.name\"]`,\n      `set(resource.attributes[\"service.namespace\"], attributes[\"service_namespace\"] ) where resource.attributes[\"service.namespace\"] == nil and attributes[\"service_namespace\"] != nil`,\n      `delete_key(attributes, \"service_namespace\") where attributes[\"service_namespace\"] == resource.attributes[\"service.namespace\"]`,\n    ]\n  }\n  log_statements {\n    context = \"resource\"\n    statements = [\n      `set(attributes[\"cluster\"], \"\")`,\n      `set(attributes[\"k8s.cluster.name\"], \"\")`,\n    ]\n  }\n\n  log_statements {\n    context = \"log\"\n    statements = [\n      `delete_key(attributes, \"loki.attribute.labels\")`,\n      `delete_key(attributes, \"loki.resource.labels\")`,\n      `set(resource.attributes[\"k8s.container.name\"], attributes[\"container\"] ) where resource.attributes[\"k8s.container.name\"] == nil and attributes[\"container\"] != nil`,\n      `delete_key(attributes, \"container\") where attributes[\"container\"] == resource.attributes[\"k8s.container.name\"]`,\n      `set(resource.attributes[\"k8s.cronjob.name\"], attributes[\"cronjob\"] ) where resource.attributes[\"k8s.cronjob.name\"] == nil and attributes[\"cronjob\"] != nil`,\n      `delete_key(attributes, \"cronjob\") where attributes[\"cronjob\"] == resource.attributes[\"k8s.cronjob.name\"]`,\n      `set(resource.attributes[\"k8s.daemonset.name\"], attributes[\"daemonset\"] ) where resource.attributes[\"k8s.daemonset.name\"] == nil and attributes[\"daemonset\"] != nil`,\n      `delete_key(attributes, \"daemonset\") where attributes[\"daemonset\"] == resource.attributes[\"k8s.daemonset.name\"]`,\n      `set(resource.attributes[\"k8s.deployment.name\"], attributes[\"deployment\"] ) where resource.attributes[\"k8s.deployment.name\"] == nil and attributes[\"deployment\"] != nil`,\n      `delete_key(attributes, \"deployment\") where attributes[\"deployment\"] == resource.attributes[\"k8s.deployment.name\"]`,\n      `set(resource.attributes[\"deployment.environment\"], attributes[\"deployment_environment\"] ) where resource.attributes[\"deployment.environment\"] == nil and attributes[\"deployment_environment\"] != nil`,\n      `delete_key(attributes, \"deployment_environment\") where attributes[\"deployment_environment\"] == resource.attributes[\"deployment.environment\"]`,\n      `set(resource.attributes[\"deployment.environment.name\"], attributes[\"deployment_environment_name\"] ) where resource.attributes[\"deployment.environment.name\"] == nil and attributes[\"deployment_environment_name\"] != nil`,\n      `delete_key(attributes, \"deployment_environment_name\") where attributes[\"deployment_environment_name\"] == resource.attributes[\"deployment.environment.name\"]`,\n      `set(resource.attributes[\"k8s.job.name\"], attributes[\"job_name\"] ) where resource.attributes[\"k8s.job.name\"] == nil and attributes[\"job_name\"] != nil`,\n      `delete_key(attributes, \"job_name\") where attributes[\"job_name\"] == resource.attributes[\"k8s.job.name\"]`,\n      `set(resource.attributes[\"k8s.namespace.name\"], attributes[\"namespace\"] ) where resource.attributes[\"k8s.namespace.name\"] == nil and attributes[\"namespace\"] != nil`,\n      `delete_key(attributes, \"namespace\") where attributes[\"namespace\"] == resource.attributes[\"k8s.namespace.name\"]`,\n      `set(resource.attributes[\"k8s.pod.name\"], attributes[\"pod\"] ) where resource.attributes[\"k8s.pod.name\"] == nil and attributes[\"pod\"] != nil`,\n      `delete_key(attributes, \"pod\") where attributes[\"pod\"] == resource.attributes[\"k8s.pod.name\"]`,\n      `set(resource.attributes[\"k8s.replicaset.name\"], attributes[\"replicaset\"] ) where resource.attributes[\"k8s.replicaset.name\"] == nil and attributes[\"replicaset\"] != nil`,\n      `delete_key(attributes, \"replicaset\") where attributes[\"replicaset\"] == resource.attributes[\"k8s.replicaset.name\"]`,\n      `set(resource.attributes[\"service.name\"], attributes[\"service_name\"] ) where resource.attributes[\"service.name\"] == nil and attributes[\"service_name\"] != nil`,\n      `delete_key(attributes, \"service_name\") where attributes[\"service_name\"] == resource.attributes[\"service.name\"]`,\n      `set(resource.attributes[\"service.namespace\"], attributes[\"service_namespace\"] ) where resource.attributes[\"service.namespace\"] == nil and attributes[\"service_namespace\"] != nil`,\n      `delete_key(attributes, \"service_namespace\") where attributes[\"service_namespace\"] == resource.attributes[\"service.namespace\"]`,\n      `set(resource.attributes[\"k8s.statefulset.name\"], attributes[\"statefulset\"] ) where resource.attributes[\"k8s.statefulset.name\"] == nil and attributes[\"statefulset\"] != nil`,\n      `delete_key(attributes, \"statefulset\") where attributes[\"statefulset\"] == resource.attributes[\"k8s.statefulset.name\"]`,\n    ]\n  }\n\n  trace_statements {\n    context = \"resource\"\n    statements = [\n      `set(attributes[\"cluster\"], \"\")`,\n      `set(attributes[\"k8s.cluster.name\"], \"\")`,\n    ]\n  }\n\n\n  output {\n    metrics = [otelcol.processor.batch.tempo.input]\n    logs = [otelcol.processor.batch.tempo.input]\n    traces = [otelcol.processor.batch.tempo.input]\n  }\n}\n\notelcol.exporter.loadbalancing \"tempo\" {\n  resolver {\n    kubernetes {\n      service = \"RELEASE-NAME-tempo-sampler\"\n    }\n  }\n  protocol {\n    otlp {\n      client {\n        tls {\n          insecure = true\n        }\n      }\n    }\n  }\n}\n\notelcol.processor.batch \"tempo\" {\n  timeout = \"2s\"\n  send_batch_size = 8192\n  send_batch_max_size = 0\n\n  output {\n    metrics = [otelcol.exporter.otlp.tempo.input]\n    logs = [otelcol.exporter.otlp.tempo.input]\n    traces = [otelcol.exporter.otlp.tempo.input]\n  }\n}\notelcol.exporter.otlp \"tempo\" {\n  client {\n    endpoint = \"tempo:4317\"\n    tls {\n      insecure = false\n      insecure_skip_verify = false\n    }\n  }\n\n  retry_on_failure {\n    enabled = true\n    initial_interval = \"5s\"\n    max_interval = \"30s\"\n    max_elapsed_time = \"5m\"\n  }\n}\n"
          create: true
      controller:
        replicas: 1
        type: statefulset
