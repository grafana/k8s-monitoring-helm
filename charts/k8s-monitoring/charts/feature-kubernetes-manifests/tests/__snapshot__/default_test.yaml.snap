should allow filtering by namespace:
  1: |
    |-
      declare "kubernetes_manifests" {
        argument "logs_destinations" {
          comment = "Must be a list of log destinations where collected logs should be forwarded to"
        }


        otelcol.receiver.filelog "deployment_manifests" {
          include = ["/var/kubernetes-manifests/deployments/*/*.json"]
          include_file_path_resolved = true
          start_at = "beginning"
          delete_after_read = true

          output {
            logs = [otelcol.processor.transform.deployment_manifests.input]
          }
        }

        otelcol.processor.transform "deployment_manifests" {
          error_mode = "ignore"

          log_statements {
            context = "log"
            statements = [
              `merge_maps(attributes, ExtractPatterns(log.attributes["log.file.path_resolved"], "^/var/kubernetes-manifests/deployments/(?P<namespace>[^/]+)/(?P<deployment>[^.]+)\\.json$"), "upsert")`,
              `set(resource.attributes["k8s.namespace.name"], attributes["namespace"])`,
              `set(resource.attributes["k8s.deployment.name"], attributes["deployment"])`,
              `set(resource.attributes["service.name"], "k8s.grafana.com/manifest-collector")`,
              `set(resource.attributes["service.namespace"], "NAMESPACE")`,
            ]
          }

          output {
            logs = argument.logs_destinations.value
          }
        }


        otelcol.receiver.filelog "statefulset_manifests" {
          include = ["/var/kubernetes-manifests/statefulsets/*/*.json"]
          include_file_path_resolved = true
          start_at = "beginning"
          delete_after_read = true

          output {
            logs = [otelcol.processor.transform.statefulset_manifests.input]
          }
        }

        otelcol.processor.transform "statefulset_manifests" {
          error_mode = "ignore"

          log_statements {
            context = "log"
            statements = [
              `merge_maps(attributes, ExtractPatterns(log.attributes["log.file.path_resolved"], "^/var/kubernetes-manifests/statefulsets/(?P<namespace>[^/]+)/(?P<statefulset>[^.]+)\\.json$"), "upsert")`,
              `set(resource.attributes["k8s.namespace.name"], attributes["namespace"])`,
              `set(resource.attributes["k8s.statefulset.name"], attributes["statefulset"])`,
              `set(resource.attributes["service.name"], "k8s.grafana.com/manifest-collector")`,
              `set(resource.attributes["service.namespace"], "NAMESPACE")`,
            ]
          }

          output {
            logs = argument.logs_destinations.value
          }
        }


        otelcol.receiver.filelog "daemonset_manifests" {
          include = ["/var/kubernetes-manifests/daemonsets/*/*.json"]
          include_file_path_resolved = true
          start_at = "beginning"
          delete_after_read = true

          output {
            logs = [otelcol.processor.transform.daemonset_manifests.input]
          }
        }

        otelcol.processor.transform "daemonset_manifests" {
          error_mode = "ignore"

          log_statements {
            context = "log"
            statements = [
              `merge_maps(attributes, ExtractPatterns(log.attributes["log.file.path_resolved"], "^/var/kubernetes-manifests/daemonsets/(?P<namespace>[^/]+)/(?P<daemonset>[^.]+)\\.json$"), "upsert")`,
              `set(resource.attributes["k8s.namespace.name"], attributes["namespace"])`,
              `set(resource.attributes["k8s.daemonset.name"], attributes["daemonset"])`,
              `set(resource.attributes["service.name"], "k8s.grafana.com/manifest-collector")`,
              `set(resource.attributes["service.namespace"], "NAMESPACE")`,
            ]
          }

          output {
            logs = argument.logs_destinations.value
          }
        }


        otelcol.receiver.filelog "cronjob_manifests" {
          include = ["/var/kubernetes-manifests/cronjobs/*/*.json"]
          include_file_path_resolved = true
          start_at = "beginning"
          delete_after_read = true

          output {
            logs = [otelcol.processor.transform.cronjob_manifests.input]
          }
        }

        otelcol.processor.transform "cronjob_manifests" {
          error_mode = "ignore"

          log_statements {
            context = "log"
            statements = [
              `merge_maps(attributes, ExtractPatterns(log.attributes["log.file.path_resolved"], "^/var/kubernetes-manifests/cronjobs/(?P<namespace>[^/]+)/(?P<cronjob>[^.]+)\\.json$"), "upsert")`,
              `set(resource.attributes["k8s.namespace.name"], attributes["namespace"])`,
              `set(resource.attributes["k8s.cronjob.name"], attributes["cronjob"])`,
              `set(resource.attributes["service.name"], "k8s.grafana.com/manifest-collector")`,
              `set(resource.attributes["service.namespace"], "NAMESPACE")`,
            ]
          }

          output {
            logs = argument.logs_destinations.value
          }
        }
      }
  2: |
    command:
      - /bin/bash
      - -c
      - |
        set -euo pipefail
        pids=()
        bash /etc/alloy/collect-manifests.sh --kind cronjobs --namespace "default" --watch-timeout "1d" &
        pids+=("$!")
        bash /etc/alloy/collect-manifests.sh --kind cronjobs --namespace "production" --watch-timeout "1d" &
        pids+=("$!")
        bash /etc/alloy/collect-manifests.sh --kind daemonsets --namespace "default" --watch-timeout "1d" &
        pids+=("$!")
        bash /etc/alloy/collect-manifests.sh --kind daemonsets --namespace "production" --watch-timeout "1d" &
        pids+=("$!")
        bash /etc/alloy/collect-manifests.sh --kind deployments --namespace "default" --watch-timeout "1d" &
        pids+=("$!")
        bash /etc/alloy/collect-manifests.sh --kind deployments --namespace "production" --watch-timeout "1d" &
        pids+=("$!")
        bash /etc/alloy/collect-manifests.sh --kind pod --namespace "default" --watch-timeout "1d" &
        pids+=("$!")
        bash /etc/alloy/collect-manifests.sh --kind pod --namespace "production" --watch-timeout "1d" &
        pids+=("$!")
        bash /etc/alloy/collect-manifests.sh --kind statefulsets --namespace "default" --watch-timeout "1d" &
        pids+=("$!")
        bash /etc/alloy/collect-manifests.sh --kind statefulsets --namespace "production" --watch-timeout "1d" &
        pids+=("$!")
        trap 'for pid in "${pids[@]}"; do kill "${pid}" 2>/dev/null || true; done' EXIT
        wait -n "${pids[@]}"
    env:
      - name: MANIFEST_DIR
        value: /var/kubernetes-manifests
    image: ghcr.io/grafana/helm-chart-toolbox-kubectl:0.1.3
    imagePullPolicy: IfNotPresent
    name: kubernetes-manifest-collector
    volumeMounts:
      - mountPath: /etc/alloy
        name: config
      - mountPath: /var/kubernetes-manifests
        name: kubernetes-manifests
        readOnly: false
should render the default configuration:
  1: |
    |-
      declare "kubernetes_manifests" {
        argument "logs_destinations" {
          comment = "Must be a list of log destinations where collected logs should be forwarded to"
        }


        otelcol.receiver.filelog "deployment_manifests" {
          include = ["/var/kubernetes-manifests/deployments/*/*.json"]
          include_file_path_resolved = true
          start_at = "beginning"
          delete_after_read = true

          output {
            logs = [otelcol.processor.transform.deployment_manifests.input]
          }
        }

        otelcol.processor.transform "deployment_manifests" {
          error_mode = "ignore"

          log_statements {
            context = "log"
            statements = [
              `merge_maps(attributes, ExtractPatterns(log.attributes["log.file.path_resolved"], "^/var/kubernetes-manifests/deployments/(?P<namespace>[^/]+)/(?P<deployment>[^.]+)\\.json$"), "upsert")`,
              `set(resource.attributes["k8s.namespace.name"], attributes["namespace"])`,
              `set(resource.attributes["k8s.deployment.name"], attributes["deployment"])`,
              `set(resource.attributes["service.name"], "k8s.grafana.com/manifest-collector")`,
              `set(resource.attributes["service.namespace"], "NAMESPACE")`,
            ]
          }

          output {
            logs = argument.logs_destinations.value
          }
        }


        otelcol.receiver.filelog "statefulset_manifests" {
          include = ["/var/kubernetes-manifests/statefulsets/*/*.json"]
          include_file_path_resolved = true
          start_at = "beginning"
          delete_after_read = true

          output {
            logs = [otelcol.processor.transform.statefulset_manifests.input]
          }
        }

        otelcol.processor.transform "statefulset_manifests" {
          error_mode = "ignore"

          log_statements {
            context = "log"
            statements = [
              `merge_maps(attributes, ExtractPatterns(log.attributes["log.file.path_resolved"], "^/var/kubernetes-manifests/statefulsets/(?P<namespace>[^/]+)/(?P<statefulset>[^.]+)\\.json$"), "upsert")`,
              `set(resource.attributes["k8s.namespace.name"], attributes["namespace"])`,
              `set(resource.attributes["k8s.statefulset.name"], attributes["statefulset"])`,
              `set(resource.attributes["service.name"], "k8s.grafana.com/manifest-collector")`,
              `set(resource.attributes["service.namespace"], "NAMESPACE")`,
            ]
          }

          output {
            logs = argument.logs_destinations.value
          }
        }


        otelcol.receiver.filelog "daemonset_manifests" {
          include = ["/var/kubernetes-manifests/daemonsets/*/*.json"]
          include_file_path_resolved = true
          start_at = "beginning"
          delete_after_read = true

          output {
            logs = [otelcol.processor.transform.daemonset_manifests.input]
          }
        }

        otelcol.processor.transform "daemonset_manifests" {
          error_mode = "ignore"

          log_statements {
            context = "log"
            statements = [
              `merge_maps(attributes, ExtractPatterns(log.attributes["log.file.path_resolved"], "^/var/kubernetes-manifests/daemonsets/(?P<namespace>[^/]+)/(?P<daemonset>[^.]+)\\.json$"), "upsert")`,
              `set(resource.attributes["k8s.namespace.name"], attributes["namespace"])`,
              `set(resource.attributes["k8s.daemonset.name"], attributes["daemonset"])`,
              `set(resource.attributes["service.name"], "k8s.grafana.com/manifest-collector")`,
              `set(resource.attributes["service.namespace"], "NAMESPACE")`,
            ]
          }

          output {
            logs = argument.logs_destinations.value
          }
        }


        otelcol.receiver.filelog "cronjob_manifests" {
          include = ["/var/kubernetes-manifests/cronjobs/*/*.json"]
          include_file_path_resolved = true
          start_at = "beginning"
          delete_after_read = true

          output {
            logs = [otelcol.processor.transform.cronjob_manifests.input]
          }
        }

        otelcol.processor.transform "cronjob_manifests" {
          error_mode = "ignore"

          log_statements {
            context = "log"
            statements = [
              `merge_maps(attributes, ExtractPatterns(log.attributes["log.file.path_resolved"], "^/var/kubernetes-manifests/cronjobs/(?P<namespace>[^/]+)/(?P<cronjob>[^.]+)\\.json$"), "upsert")`,
              `set(resource.attributes["k8s.namespace.name"], attributes["namespace"])`,
              `set(resource.attributes["k8s.cronjob.name"], attributes["cronjob"])`,
              `set(resource.attributes["service.name"], "k8s.grafana.com/manifest-collector")`,
              `set(resource.attributes["service.namespace"], "NAMESPACE")`,
            ]
          }

          output {
            logs = argument.logs_destinations.value
          }
        }
      }
  2: |
    command:
      - /bin/bash
      - -c
      - |
        set -euo pipefail
        pids=()
        bash /etc/alloy/collect-manifests.sh --kind cronjobs --watch-timeout "1d" &
        pids+=("$!")
        bash /etc/alloy/collect-manifests.sh --kind daemonsets --watch-timeout "1d" &
        pids+=("$!")
        bash /etc/alloy/collect-manifests.sh --kind deployments --watch-timeout "1d" &
        pids+=("$!")
        bash /etc/alloy/collect-manifests.sh --kind pod --watch-timeout "1d" &
        pids+=("$!")
        bash /etc/alloy/collect-manifests.sh --kind statefulsets --watch-timeout "1d" &
        pids+=("$!")
        trap 'for pid in "${pids[@]}"; do kill "${pid}" 2>/dev/null || true; done' EXIT
        wait -n "${pids[@]}"
    env:
      - name: MANIFEST_DIR
        value: /var/kubernetes-manifests
    image: ghcr.io/grafana/helm-chart-toolbox-kubectl:0.1.3
    imagePullPolicy: IfNotPresent
    name: kubernetes-manifest-collector
    volumeMounts:
      - mountPath: /etc/alloy
        name: config
      - mountPath: /var/kubernetes-manifests
        name: kubernetes-manifests
        readOnly: false
