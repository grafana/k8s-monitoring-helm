should add the attach_metadata block to the discovery.kubernetes:
  1: |
    |-
      declare "pod_logs_via_kubernetes_api" {
        argument "logs_destinations" {
          comment = "Must be a list of log destinations where collected logs should be forwarded to"
        }

        discovery.kubernetes "pods" {
          role = "pod"
        attach_metadata {
          node = true
        }
        }

        discovery.relabel "filtered_pods" {
          targets = discovery.kubernetes.pods.targets
          rule {
            source_labels = ["__meta_kubernetes_namespace"]
            action = "replace"
            target_label = "namespace"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_name"]
            target_label = "pod"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_container_name"]
            target_label = "container"
          }
          rule {
            source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
            separator = "/"
            target_label = "job"
          }

          // set the container runtime as a label
          rule {
            source_labels = ["__meta_kubernetes_pod_container_id"]
            regex = "^(\\S+):\\/\\/.+$"
            target_label = "tmp_container_runtime"
          }

          // explicitly set service_name. if not set, loki will automatically try to populate a default.
          // see https://grafana.com/docs/loki/latest/get-started/labels/#default-labels-for-all-users
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.name]
          // - pod.label[app.kubernetes.io/name]
          // - k8s.pod.name
          // - k8s.container.name
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_name",
              "__meta_kubernetes_pod_label_app_kubernetes_io_name",
              "container",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_name"
          }

          // explicitly set service_namespace.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.namespace]
          // - pod.namespace
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_namespace",
              "namespace",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_namespace"
          }

          // explicitly set service_instance_id.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.instance.id]
          // - concat([k8s.namespace.name, k8s.pod.name, k8s.container.name], '.')
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_instance_id"]
            target_label = "service_instance_id"
          }
          rule {
            source_labels = ["service_instance_id", "namespace", "pod", "container"]
            separator = "."
            regex = "^\\.([^.]+\\.[^.]+\\.[^.]+)$"
            target_label = "service_instance_id"
          }

          // set resource attributes
          rule {
            action = "labelmap"
            regex = "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_(.+)"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_logs_job"]
            regex = "(.+)"
            target_label = "job"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
            regex = "(.+)"
            target_label = "app_kubernetes_io_name"
          }

          rule {
            source_labels = [
              "__meta_kubernetes_node_label_karpenter_sh_nodepool",
              "__meta_kubernetes_node_label_cloud_google_com_gke_nodepool",
              "__meta_kubernetes_node_label_eks_amazonaws_com_nodegroup",
              "__meta_kubernetes_node_label_kubernetes_azure_com_agentpool",
              "__meta_kubernetes_node_label_agentpool",
            ]
            regex = "^(?:;*)?([^;]+).*$"
            target_label = "nodepool"
          }
        }

        loki.source.kubernetes "pod_logs" {
          targets = discovery.relabel.filtered_pods.output
          clustering {
            enabled = true
          }
          forward_to = [loki.process.pod_logs.receiver]
        }

        loki.process "pod_logs" {
          stage.match {
            selector = "{tmp_container_runtime=~\"containerd|cri-o\"}"
            // the cri processing stage extracts the following k/v pairs: log, stream, time, flags
            stage.cri {}

            // Set the extract flags and stream values as labels
            stage.labels {
              values = {
                flags  = "",
                stream  = "",
              }
            }
          }

          stage.match {
            selector = "{tmp_container_runtime=\"docker\"}"
            // the docker processing stage extracts the following k/v pairs: log, stream, time
            stage.docker {}

            // Set the extract stream value as a label
            stage.labels {
              values = {
                stream  = "",
              }
            }
          }

          // Drop the filename label, since it's not really useful in the context of Kubernetes, where we already have cluster,
          // namespace, pod, and container labels. Drop any structured metadata. Also drop the temporary
          // container runtime label as it is no longer needed.
          stage.label_drop {
            values = [
              "filename",
              "tmp_container_runtime",
            ]
          }
          stage.structured_metadata {
            values = {
              "k8s_pod_name" = "k8s_pod_name",
              "pod" = "pod",
              "service_instance_id" = "service_instance_id",
            }
          }

          forward_to = argument.logs_destinations.value
        }
      }
should add the node architecture label rules to the discovery relabel:
  1: |
    |-
      declare "pod_logs_via_kubernetes_api" {
        argument "logs_destinations" {
          comment = "Must be a list of log destinations where collected logs should be forwarded to"
        }

        discovery.kubernetes "pods" {
          role = "pod"
        attach_metadata {
          node = true
        }
        }

        discovery.relabel "filtered_pods" {
          targets = discovery.kubernetes.pods.targets
          rule {
            source_labels = ["__meta_kubernetes_namespace"]
            action = "replace"
            target_label = "namespace"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_name"]
            target_label = "pod"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_container_name"]
            target_label = "container"
          }
          rule {
            source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
            separator = "/"
            target_label = "job"
          }

          // set the container runtime as a label
          rule {
            source_labels = ["__meta_kubernetes_pod_container_id"]
            regex = "^(\\S+):\\/\\/.+$"
            target_label = "tmp_container_runtime"
          }

          // explicitly set service_name. if not set, loki will automatically try to populate a default.
          // see https://grafana.com/docs/loki/latest/get-started/labels/#default-labels-for-all-users
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.name]
          // - pod.label[app.kubernetes.io/name]
          // - k8s.pod.name
          // - k8s.container.name
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_name",
              "__meta_kubernetes_pod_label_app_kubernetes_io_name",
              "container",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_name"
          }

          // explicitly set service_namespace.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.namespace]
          // - pod.namespace
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_namespace",
              "namespace",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_namespace"
          }

          // explicitly set service_instance_id.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.instance.id]
          // - concat([k8s.namespace.name, k8s.pod.name, k8s.container.name], '.')
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_instance_id"]
            target_label = "service_instance_id"
          }
          rule {
            source_labels = ["service_instance_id", "namespace", "pod", "container"]
            separator = "."
            regex = "^\\.([^.]+\\.[^.]+\\.[^.]+)$"
            target_label = "service_instance_id"
          }

          // set resource attributes
          rule {
            action = "labelmap"
            regex = "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_(.+)"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_logs_job"]
            regex = "(.+)"
            target_label = "job"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
            regex = "(.+)"
            target_label = "app_kubernetes_io_name"
          }

          rule {
            source_labels = [
              "__meta_kubernetes_node_label_kubernetes_io_arch",
              "__meta_kubernetes_node_label_beta_kubernetes_io_arch",
            ]
            regex = "^(?:;*)?([^;]+).*$"
            target_label = "architecture"
          }
        }

        loki.source.kubernetes "pod_logs" {
          targets = discovery.relabel.filtered_pods.output
          clustering {
            enabled = true
          }
          forward_to = [loki.process.pod_logs.receiver]
        }

        loki.process "pod_logs" {
          stage.match {
            selector = "{tmp_container_runtime=~\"containerd|cri-o\"}"
            // the cri processing stage extracts the following k/v pairs: log, stream, time, flags
            stage.cri {}

            // Set the extract flags and stream values as labels
            stage.labels {
              values = {
                flags  = "",
                stream  = "",
              }
            }
          }

          stage.match {
            selector = "{tmp_container_runtime=\"docker\"}"
            // the docker processing stage extracts the following k/v pairs: log, stream, time
            stage.docker {}

            // Set the extract stream value as a label
            stage.labels {
              values = {
                stream  = "",
              }
            }
          }

          // Drop the filename label, since it's not really useful in the context of Kubernetes, where we already have cluster,
          // namespace, pod, and container labels. Drop any structured metadata. Also drop the temporary
          // container runtime label as it is no longer needed.
          stage.label_drop {
            values = [
              "filename",
              "tmp_container_runtime",
            ]
          }
          stage.structured_metadata {
            values = {
              "architecture" = "architecture",
              "k8s_pod_name" = "k8s_pod_name",
              "pod" = "pod",
              "service_instance_id" = "service_instance_id",
            }
          }

          forward_to = argument.logs_destinations.value
        }
      }
should add the node availability zone label rules to the discovery relabel:
  1: |
    |-
      declare "pod_logs_via_kubernetes_api" {
        argument "logs_destinations" {
          comment = "Must be a list of log destinations where collected logs should be forwarded to"
        }

        discovery.kubernetes "pods" {
          role = "pod"
        attach_metadata {
          node = true
        }
        }

        discovery.relabel "filtered_pods" {
          targets = discovery.kubernetes.pods.targets
          rule {
            source_labels = ["__meta_kubernetes_namespace"]
            action = "replace"
            target_label = "namespace"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_name"]
            target_label = "pod"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_container_name"]
            target_label = "container"
          }
          rule {
            source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
            separator = "/"
            target_label = "job"
          }

          // set the container runtime as a label
          rule {
            source_labels = ["__meta_kubernetes_pod_container_id"]
            regex = "^(\\S+):\\/\\/.+$"
            target_label = "tmp_container_runtime"
          }

          // explicitly set service_name. if not set, loki will automatically try to populate a default.
          // see https://grafana.com/docs/loki/latest/get-started/labels/#default-labels-for-all-users
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.name]
          // - pod.label[app.kubernetes.io/name]
          // - k8s.pod.name
          // - k8s.container.name
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_name",
              "__meta_kubernetes_pod_label_app_kubernetes_io_name",
              "container",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_name"
          }

          // explicitly set service_namespace.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.namespace]
          // - pod.namespace
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_namespace",
              "namespace",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_namespace"
          }

          // explicitly set service_instance_id.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.instance.id]
          // - concat([k8s.namespace.name, k8s.pod.name, k8s.container.name], '.')
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_instance_id"]
            target_label = "service_instance_id"
          }
          rule {
            source_labels = ["service_instance_id", "namespace", "pod", "container"]
            separator = "."
            regex = "^\\.([^.]+\\.[^.]+\\.[^.]+)$"
            target_label = "service_instance_id"
          }

          // set resource attributes
          rule {
            action = "labelmap"
            regex = "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_(.+)"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_logs_job"]
            regex = "(.+)"
            target_label = "job"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
            regex = "(.+)"
            target_label = "app_kubernetes_io_name"
          }

          rule {
            source_labels = [
              "__meta_kubernetes_node_label_topology_kubernetes_io_zone",
              "__meta_kubernetes_node_label_failure_domain_beta_kubernetes_io_zone",
              "__meta_kubernetes_node_label_topology_gke_io_zone",
            ]
            regex = "^(?:;*)?([^;]+).*$"
            target_label = "availability_zone"
          }
        }

        loki.source.kubernetes "pod_logs" {
          targets = discovery.relabel.filtered_pods.output
          clustering {
            enabled = true
          }
          forward_to = [loki.process.pod_logs.receiver]
        }

        loki.process "pod_logs" {
          stage.match {
            selector = "{tmp_container_runtime=~\"containerd|cri-o\"}"
            // the cri processing stage extracts the following k/v pairs: log, stream, time, flags
            stage.cri {}

            // Set the extract flags and stream values as labels
            stage.labels {
              values = {
                flags  = "",
                stream  = "",
              }
            }
          }

          stage.match {
            selector = "{tmp_container_runtime=\"docker\"}"
            // the docker processing stage extracts the following k/v pairs: log, stream, time
            stage.docker {}

            // Set the extract stream value as a label
            stage.labels {
              values = {
                stream  = "",
              }
            }
          }

          // Drop the filename label, since it's not really useful in the context of Kubernetes, where we already have cluster,
          // namespace, pod, and container labels. Drop any structured metadata. Also drop the temporary
          // container runtime label as it is no longer needed.
          stage.label_drop {
            values = [
              "filename",
              "tmp_container_runtime",
            ]
          }
          stage.structured_metadata {
            values = {
              "availability_zone" = "availability_zone",
              "k8s_pod_name" = "k8s_pod_name",
              "pod" = "pod",
              "service_instance_id" = "service_instance_id",
            }
          }

          forward_to = argument.logs_destinations.value
        }
      }
should add the node instance type label rules to the discovery relabel:
  1: |
    |-
      declare "pod_logs_via_kubernetes_api" {
        argument "logs_destinations" {
          comment = "Must be a list of log destinations where collected logs should be forwarded to"
        }

        discovery.kubernetes "pods" {
          role = "pod"
        attach_metadata {
          node = true
        }
        }

        discovery.relabel "filtered_pods" {
          targets = discovery.kubernetes.pods.targets
          rule {
            source_labels = ["__meta_kubernetes_namespace"]
            action = "replace"
            target_label = "namespace"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_name"]
            target_label = "pod"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_container_name"]
            target_label = "container"
          }
          rule {
            source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
            separator = "/"
            target_label = "job"
          }

          // set the container runtime as a label
          rule {
            source_labels = ["__meta_kubernetes_pod_container_id"]
            regex = "^(\\S+):\\/\\/.+$"
            target_label = "tmp_container_runtime"
          }

          // explicitly set service_name. if not set, loki will automatically try to populate a default.
          // see https://grafana.com/docs/loki/latest/get-started/labels/#default-labels-for-all-users
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.name]
          // - pod.label[app.kubernetes.io/name]
          // - k8s.pod.name
          // - k8s.container.name
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_name",
              "__meta_kubernetes_pod_label_app_kubernetes_io_name",
              "container",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_name"
          }

          // explicitly set service_namespace.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.namespace]
          // - pod.namespace
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_namespace",
              "namespace",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_namespace"
          }

          // explicitly set service_instance_id.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.instance.id]
          // - concat([k8s.namespace.name, k8s.pod.name, k8s.container.name], '.')
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_instance_id"]
            target_label = "service_instance_id"
          }
          rule {
            source_labels = ["service_instance_id", "namespace", "pod", "container"]
            separator = "."
            regex = "^\\.([^.]+\\.[^.]+\\.[^.]+)$"
            target_label = "service_instance_id"
          }

          // set resource attributes
          rule {
            action = "labelmap"
            regex = "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_(.+)"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_logs_job"]
            regex = "(.+)"
            target_label = "job"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
            regex = "(.+)"
            target_label = "app_kubernetes_io_name"
          }

          rule {
            source_labels = [
              "__meta_kubernetes_node_label_node_kubernetes_io_instance_type",
              "__meta_kubernetes_node_label_beta_kubernetes_io_instance_type",
            ]
            regex = "^(?:;*)?([^;]+).*$"
            target_label = "instance_type"
          }
        }

        loki.source.kubernetes "pod_logs" {
          targets = discovery.relabel.filtered_pods.output
          clustering {
            enabled = true
          }
          forward_to = [loki.process.pod_logs.receiver]
        }

        loki.process "pod_logs" {
          stage.match {
            selector = "{tmp_container_runtime=~\"containerd|cri-o\"}"
            // the cri processing stage extracts the following k/v pairs: log, stream, time, flags
            stage.cri {}

            // Set the extract flags and stream values as labels
            stage.labels {
              values = {
                flags  = "",
                stream  = "",
              }
            }
          }

          stage.match {
            selector = "{tmp_container_runtime=\"docker\"}"
            // the docker processing stage extracts the following k/v pairs: log, stream, time
            stage.docker {}

            // Set the extract stream value as a label
            stage.labels {
              values = {
                stream  = "",
              }
            }
          }

          // Drop the filename label, since it's not really useful in the context of Kubernetes, where we already have cluster,
          // namespace, pod, and container labels. Drop any structured metadata. Also drop the temporary
          // container runtime label as it is no longer needed.
          stage.label_drop {
            values = [
              "filename",
              "tmp_container_runtime",
            ]
          }
          stage.structured_metadata {
            values = {
              "instance_type" = "instance_type",
              "k8s_pod_name" = "k8s_pod_name",
              "pod" = "pod",
              "service_instance_id" = "service_instance_id",
            }
          }

          forward_to = argument.logs_destinations.value
        }
      }
should add the node os label rules to the discovery relabel:
  1: |
    |-
      declare "pod_logs_via_kubernetes_api" {
        argument "logs_destinations" {
          comment = "Must be a list of log destinations where collected logs should be forwarded to"
        }

        discovery.kubernetes "pods" {
          role = "pod"
        attach_metadata {
          node = true
        }
        }

        discovery.relabel "filtered_pods" {
          targets = discovery.kubernetes.pods.targets
          rule {
            source_labels = ["__meta_kubernetes_namespace"]
            action = "replace"
            target_label = "namespace"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_name"]
            target_label = "pod"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_container_name"]
            target_label = "container"
          }
          rule {
            source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
            separator = "/"
            target_label = "job"
          }

          // set the container runtime as a label
          rule {
            source_labels = ["__meta_kubernetes_pod_container_id"]
            regex = "^(\\S+):\\/\\/.+$"
            target_label = "tmp_container_runtime"
          }

          // explicitly set service_name. if not set, loki will automatically try to populate a default.
          // see https://grafana.com/docs/loki/latest/get-started/labels/#default-labels-for-all-users
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.name]
          // - pod.label[app.kubernetes.io/name]
          // - k8s.pod.name
          // - k8s.container.name
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_name",
              "__meta_kubernetes_pod_label_app_kubernetes_io_name",
              "container",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_name"
          }

          // explicitly set service_namespace.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.namespace]
          // - pod.namespace
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_namespace",
              "namespace",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_namespace"
          }

          // explicitly set service_instance_id.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.instance.id]
          // - concat([k8s.namespace.name, k8s.pod.name, k8s.container.name], '.')
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_instance_id"]
            target_label = "service_instance_id"
          }
          rule {
            source_labels = ["service_instance_id", "namespace", "pod", "container"]
            separator = "."
            regex = "^\\.([^.]+\\.[^.]+\\.[^.]+)$"
            target_label = "service_instance_id"
          }

          // set resource attributes
          rule {
            action = "labelmap"
            regex = "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_(.+)"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_logs_job"]
            regex = "(.+)"
            target_label = "job"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
            regex = "(.+)"
            target_label = "app_kubernetes_io_name"
          }

          rule {
            source_labels = [
              "__meta_kubernetes_node_label_kubernetes_io_os",
              "__meta_kubernetes_node_label_os_kubernetes_io",
              "__meta_kubernetes_node_label_os",
            ]
            regex = "^(?:;*)?([^;]+).*$"
            target_label = "os"
          }
        }

        loki.source.kubernetes "pod_logs" {
          targets = discovery.relabel.filtered_pods.output
          clustering {
            enabled = true
          }
          forward_to = [loki.process.pod_logs.receiver]
        }

        loki.process "pod_logs" {
          stage.match {
            selector = "{tmp_container_runtime=~\"containerd|cri-o\"}"
            // the cri processing stage extracts the following k/v pairs: log, stream, time, flags
            stage.cri {}

            // Set the extract flags and stream values as labels
            stage.labels {
              values = {
                flags  = "",
                stream  = "",
              }
            }
          }

          stage.match {
            selector = "{tmp_container_runtime=\"docker\"}"
            // the docker processing stage extracts the following k/v pairs: log, stream, time
            stage.docker {}

            // Set the extract stream value as a label
            stage.labels {
              values = {
                stream  = "",
              }
            }
          }

          // Drop the filename label, since it's not really useful in the context of Kubernetes, where we already have cluster,
          // namespace, pod, and container labels. Drop any structured metadata. Also drop the temporary
          // container runtime label as it is no longer needed.
          stage.label_drop {
            values = [
              "filename",
              "tmp_container_runtime",
            ]
          }
          stage.structured_metadata {
            values = {
              "k8s_pod_name" = "k8s_pod_name",
              "os" = "os",
              "pod" = "pod",
              "service_instance_id" = "service_instance_id",
            }
          }

          forward_to = argument.logs_destinations.value
        }
      }
should add the node pool label rules to the discovery relabel:
  1: |
    |-
      declare "pod_logs_via_kubernetes_api" {
        argument "logs_destinations" {
          comment = "Must be a list of log destinations where collected logs should be forwarded to"
        }

        discovery.kubernetes "pods" {
          role = "pod"
        attach_metadata {
          node = true
        }
        }

        discovery.relabel "filtered_pods" {
          targets = discovery.kubernetes.pods.targets
          rule {
            source_labels = ["__meta_kubernetes_namespace"]
            action = "replace"
            target_label = "namespace"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_name"]
            target_label = "pod"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_container_name"]
            target_label = "container"
          }
          rule {
            source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
            separator = "/"
            target_label = "job"
          }

          // set the container runtime as a label
          rule {
            source_labels = ["__meta_kubernetes_pod_container_id"]
            regex = "^(\\S+):\\/\\/.+$"
            target_label = "tmp_container_runtime"
          }

          // explicitly set service_name. if not set, loki will automatically try to populate a default.
          // see https://grafana.com/docs/loki/latest/get-started/labels/#default-labels-for-all-users
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.name]
          // - pod.label[app.kubernetes.io/name]
          // - k8s.pod.name
          // - k8s.container.name
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_name",
              "__meta_kubernetes_pod_label_app_kubernetes_io_name",
              "container",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_name"
          }

          // explicitly set service_namespace.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.namespace]
          // - pod.namespace
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_namespace",
              "namespace",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_namespace"
          }

          // explicitly set service_instance_id.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.instance.id]
          // - concat([k8s.namespace.name, k8s.pod.name, k8s.container.name], '.')
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_instance_id"]
            target_label = "service_instance_id"
          }
          rule {
            source_labels = ["service_instance_id", "namespace", "pod", "container"]
            separator = "."
            regex = "^\\.([^.]+\\.[^.]+\\.[^.]+)$"
            target_label = "service_instance_id"
          }

          // set resource attributes
          rule {
            action = "labelmap"
            regex = "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_(.+)"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_logs_job"]
            regex = "(.+)"
            target_label = "job"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
            regex = "(.+)"
            target_label = "app_kubernetes_io_name"
          }

          rule {
            source_labels = [
              "__meta_kubernetes_node_label_karpenter_sh_nodepool",
              "__meta_kubernetes_node_label_cloud_google_com_gke_nodepool",
              "__meta_kubernetes_node_label_eks_amazonaws_com_nodegroup",
              "__meta_kubernetes_node_label_kubernetes_azure_com_agentpool",
              "__meta_kubernetes_node_label_agentpool",
            ]
            regex = "^(?:;*)?([^;]+).*$"
            target_label = "nodepool"
          }
        }

        loki.source.kubernetes "pod_logs" {
          targets = discovery.relabel.filtered_pods.output
          clustering {
            enabled = true
          }
          forward_to = [loki.process.pod_logs.receiver]
        }

        loki.process "pod_logs" {
          stage.match {
            selector = "{tmp_container_runtime=~\"containerd|cri-o\"}"
            // the cri processing stage extracts the following k/v pairs: log, stream, time, flags
            stage.cri {}

            // Set the extract flags and stream values as labels
            stage.labels {
              values = {
                flags  = "",
                stream  = "",
              }
            }
          }

          stage.match {
            selector = "{tmp_container_runtime=\"docker\"}"
            // the docker processing stage extracts the following k/v pairs: log, stream, time
            stage.docker {}

            // Set the extract stream value as a label
            stage.labels {
              values = {
                stream  = "",
              }
            }
          }

          // Drop the filename label, since it's not really useful in the context of Kubernetes, where we already have cluster,
          // namespace, pod, and container labels. Drop any structured metadata. Also drop the temporary
          // container runtime label as it is no longer needed.
          stage.label_drop {
            values = [
              "filename",
              "tmp_container_runtime",
            ]
          }
          stage.structured_metadata {
            values = {
              "k8s_pod_name" = "k8s_pod_name",
              "nodepool" = "nodepool",
              "pod" = "pod",
              "service_instance_id" = "service_instance_id",
            }
          }

          forward_to = argument.logs_destinations.value
        }
      }
should add the node region label rules to the discovery relabel:
  1: |
    |-
      declare "pod_logs_via_kubernetes_api" {
        argument "logs_destinations" {
          comment = "Must be a list of log destinations where collected logs should be forwarded to"
        }

        discovery.kubernetes "pods" {
          role = "pod"
        attach_metadata {
          node = true
        }
        }

        discovery.relabel "filtered_pods" {
          targets = discovery.kubernetes.pods.targets
          rule {
            source_labels = ["__meta_kubernetes_namespace"]
            action = "replace"
            target_label = "namespace"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_name"]
            target_label = "pod"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_container_name"]
            target_label = "container"
          }
          rule {
            source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
            separator = "/"
            target_label = "job"
          }

          // set the container runtime as a label
          rule {
            source_labels = ["__meta_kubernetes_pod_container_id"]
            regex = "^(\\S+):\\/\\/.+$"
            target_label = "tmp_container_runtime"
          }

          // explicitly set service_name. if not set, loki will automatically try to populate a default.
          // see https://grafana.com/docs/loki/latest/get-started/labels/#default-labels-for-all-users
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.name]
          // - pod.label[app.kubernetes.io/name]
          // - k8s.pod.name
          // - k8s.container.name
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_name",
              "__meta_kubernetes_pod_label_app_kubernetes_io_name",
              "container",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_name"
          }

          // explicitly set service_namespace.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.namespace]
          // - pod.namespace
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_namespace",
              "namespace",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_namespace"
          }

          // explicitly set service_instance_id.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.instance.id]
          // - concat([k8s.namespace.name, k8s.pod.name, k8s.container.name], '.')
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_instance_id"]
            target_label = "service_instance_id"
          }
          rule {
            source_labels = ["service_instance_id", "namespace", "pod", "container"]
            separator = "."
            regex = "^\\.([^.]+\\.[^.]+\\.[^.]+)$"
            target_label = "service_instance_id"
          }

          // set resource attributes
          rule {
            action = "labelmap"
            regex = "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_(.+)"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_logs_job"]
            regex = "(.+)"
            target_label = "job"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
            regex = "(.+)"
            target_label = "app_kubernetes_io_name"
          }

          rule {
            source_labels = [
              "__meta_kubernetes_node_label_topology_kubernetes_io_region",
              "__meta_kubernetes_node_label_failure_domain_beta_kubernetes_io_region",
            ]
            regex = "^(?:;*)?([^;]+).*$"
            target_label = "region"
          }
        }

        loki.source.kubernetes "pod_logs" {
          targets = discovery.relabel.filtered_pods.output
          clustering {
            enabled = true
          }
          forward_to = [loki.process.pod_logs.receiver]
        }

        loki.process "pod_logs" {
          stage.match {
            selector = "{tmp_container_runtime=~\"containerd|cri-o\"}"
            // the cri processing stage extracts the following k/v pairs: log, stream, time, flags
            stage.cri {}

            // Set the extract flags and stream values as labels
            stage.labels {
              values = {
                flags  = "",
                stream  = "",
              }
            }
          }

          stage.match {
            selector = "{tmp_container_runtime=\"docker\"}"
            // the docker processing stage extracts the following k/v pairs: log, stream, time
            stage.docker {}

            // Set the extract stream value as a label
            stage.labels {
              values = {
                stream  = "",
              }
            }
          }

          // Drop the filename label, since it's not really useful in the context of Kubernetes, where we already have cluster,
          // namespace, pod, and container labels. Drop any structured metadata. Also drop the temporary
          // container runtime label as it is no longer needed.
          stage.label_drop {
            values = [
              "filename",
              "tmp_container_runtime",
            ]
          }
          stage.structured_metadata {
            values = {
              "k8s_pod_name" = "k8s_pod_name",
              "pod" = "pod",
              "region" = "region",
              "service_instance_id" = "service_instance_id",
            }
          }

          forward_to = argument.logs_destinations.value
        }
      }
should add the node role label rules to the discovery relabel:
  1: |
    |-
      declare "pod_logs_via_kubernetes_api" {
        argument "logs_destinations" {
          comment = "Must be a list of log destinations where collected logs should be forwarded to"
        }

        discovery.kubernetes "pods" {
          role = "pod"
        attach_metadata {
          node = true
        }
        }

        discovery.relabel "filtered_pods" {
          targets = discovery.kubernetes.pods.targets
          rule {
            source_labels = ["__meta_kubernetes_namespace"]
            action = "replace"
            target_label = "namespace"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_name"]
            target_label = "pod"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_container_name"]
            target_label = "container"
          }
          rule {
            source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
            separator = "/"
            target_label = "job"
          }

          // set the container runtime as a label
          rule {
            source_labels = ["__meta_kubernetes_pod_container_id"]
            regex = "^(\\S+):\\/\\/.+$"
            target_label = "tmp_container_runtime"
          }

          // explicitly set service_name. if not set, loki will automatically try to populate a default.
          // see https://grafana.com/docs/loki/latest/get-started/labels/#default-labels-for-all-users
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.name]
          // - pod.label[app.kubernetes.io/name]
          // - k8s.pod.name
          // - k8s.container.name
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_name",
              "__meta_kubernetes_pod_label_app_kubernetes_io_name",
              "container",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_name"
          }

          // explicitly set service_namespace.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.namespace]
          // - pod.namespace
          rule {
            action = "replace"
            source_labels = [
              "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_namespace",
              "namespace",
            ]
            separator = ";"
            regex = "^(?:;*)?([^;]+).*$"
            replacement = "$1"
            target_label = "service_namespace"
          }

          // explicitly set service_instance_id.
          //
          // choose the first value found from the following ordered list:
          // - pod.annotation[resource.opentelemetry.io/service.instance.id]
          // - concat([k8s.namespace.name, k8s.pod.name, k8s.container.name], '.')
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_resource_opentelemetry_io_service_instance_id"]
            target_label = "service_instance_id"
          }
          rule {
            source_labels = ["service_instance_id", "namespace", "pod", "container"]
            separator = "."
            regex = "^\\.([^.]+\\.[^.]+\\.[^.]+)$"
            target_label = "service_instance_id"
          }

          // set resource attributes
          rule {
            action = "labelmap"
            regex = "__meta_kubernetes_pod_annotation_resource_opentelemetry_io_(.+)"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_logs_job"]
            regex = "(.+)"
            target_label = "job"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
            regex = "(.+)"
            target_label = "app_kubernetes_io_name"
          }

          rule {
            source_labels = [
              "__meta_kubernetes_node_label_kubernetes_io_role",
              "__meta_kubernetes_node_label_node_kubernetes_io_role",
              "__meta_kubernetes_node_label_node_role",
              "__meta_kubernetes_node_label_role",
            ]
            regex = "^(?:;*)?([^;]+).*$"
            target_label = "node_role"
          }
        }

        loki.source.kubernetes "pod_logs" {
          targets = discovery.relabel.filtered_pods.output
          clustering {
            enabled = true
          }
          forward_to = [loki.process.pod_logs.receiver]
        }

        loki.process "pod_logs" {
          stage.match {
            selector = "{tmp_container_runtime=~\"containerd|cri-o\"}"
            // the cri processing stage extracts the following k/v pairs: log, stream, time, flags
            stage.cri {}

            // Set the extract flags and stream values as labels
            stage.labels {
              values = {
                flags  = "",
                stream  = "",
              }
            }
          }

          stage.match {
            selector = "{tmp_container_runtime=\"docker\"}"
            // the docker processing stage extracts the following k/v pairs: log, stream, time
            stage.docker {}

            // Set the extract stream value as a label
            stage.labels {
              values = {
                stream  = "",
              }
            }
          }

          // Drop the filename label, since it's not really useful in the context of Kubernetes, where we already have cluster,
          // namespace, pod, and container labels. Drop any structured metadata. Also drop the temporary
          // container runtime label as it is no longer needed.
          stage.label_drop {
            values = [
              "filename",
              "tmp_container_runtime",
            ]
          }
          stage.structured_metadata {
            values = {
              "k8s_pod_name" = "k8s_pod_name",
              "node_role" = "node_role",
              "pod" = "pod",
              "service_instance_id" = "service_instance_id",
            }
          }

          forward_to = argument.logs_destinations.value
        }
      }
