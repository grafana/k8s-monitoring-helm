creates a module with default discovery, scraping, and processing configurations:
  1: |
    |-
      declare "annotation_autodiscovery" {
        argument "metrics_destinations" {
          comment = "Must be a list of metric destinations where collected metrics should be forwarded to"
        }

        discovery.kubernetes "pods" {
          role = "pod"
        }

        discovery.relabel "annotation_autodiscovery_pods" {
          targets = discovery.kubernetes.pods.targets
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_scrape"]
            regex = "true"
            action = "keep"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_job"]
            action = "replace"
            target_label = "job"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_instance"]
            action = "replace"
            target_label = "instance"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_metrics_path"]
            action = "replace"
            target_label = "__metrics_path__"
          }

          // Choose the pod port
          // The discovery generates a target for each declared container port of the pod.
          // If the metricsPortName annotation has value, keep only the target where the port name matches the one of the annotation.
          rule {
            source_labels = ["__meta_kubernetes_pod_container_port_name"]
            target_label = "__tmp_port"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_metrics_portName"]
            regex = "(.+)"
            target_label = "__tmp_port"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_container_port_name"]
            action = "keepequal"
            target_label = "__tmp_port"
          }
          rule {
            action = "labeldrop"
            regex = "__tmp_port"
          }

          // If the metrics port number annotation has a value, override the target address to use it, regardless whether it is
          // one of the declared ports on that Pod.
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_metrics_portNumber", "__meta_kubernetes_pod_ip"]
            regex = "(\\d+);(([A-Fa-f0-9]{1,4}::?){1,7}[A-Fa-f0-9]{1,4})"
            replacement = "[$2]:$1" // IPv6
            target_label = "__address__"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_metrics_portNumber", "__meta_kubernetes_pod_ip"]
            regex = "(\\d+);((([0-9]+?)(\\.|$)){4})" // IPv4, takes priority over IPv6 when both exists
            replacement = "$2:$1"
            target_label = "__address__"
          }

          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_metrics_scheme"]
            regex = "(.+)"
            target_label = "__scheme__"
          }

          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_metrics_scrapeInterval"]
            regex = "(.+)"
            target_label = "__scrape_interval__"
          }
          rule {
            source_labels = ["__scrape_interval__"]
            regex = ""
            replacement = "60s"
            target_label = "__scrape_interval__"
          }
          rule {
            source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_metrics_scrapeTimeout"]
            regex = "(.+)"
            target_label = "__scrape_timeout__"
          }
          rule {
            source_labels = ["__scrape_timeout__"]
            regex = ""
            replacement = "10s"
            target_label = "__scrape_timeout__"
          }
        }

        discovery.kubernetes "services" {
          role = "service"
        }

        discovery.relabel "annotation_autodiscovery_services" {
          targets = discovery.kubernetes.services.targets
          rule {
            source_labels = ["__meta_kubernetes_service_annotation_k8s_grafana_com_scrape"]
            regex = "true"
            action = "keep"
          }
          rule {
            source_labels = ["__meta_kubernetes_service_annotation_k8s_grafana_com_job"]
            action = "replace"
            target_label = "job"
          }
          rule {
            source_labels = ["__meta_kubernetes_service_annotation_k8s_grafana_com_instance"]
            action = "replace"
            target_label = "instance"
          }
          rule {
            source_labels = ["__meta_kubernetes_service_annotation_k8s_grafana_com_metrics_path"]
            action = "replace"
            target_label = "__metrics_path__"
          }

          // Choose the service port
          rule {
            source_labels = ["__meta_kubernetes_service_port_name"]
            target_label = "__tmp_port"
          }
          rule {
            source_labels = ["__meta_kubernetes_service_annotation_k8s_grafana_com_metrics_portName"]
            regex = "(.+)"
            target_label = "__tmp_port"
          }
          rule {
            source_labels = ["__meta_kubernetes_service_port_name"]
            action = "keepequal"
            target_label = "__tmp_port"
          }

          rule {
            source_labels = ["__meta_kubernetes_service_port_number"]
            target_label = "__tmp_port"
          }
          rule {
            source_labels = ["__meta_kubernetes_service_annotation_k8s_grafana_com_metrics_portNumber"]
            regex = "(.+)"
            target_label = "__tmp_port"
          }
          rule {
            source_labels = ["__meta_kubernetes_service_port_number"]
            action = "keepequal"
            target_label = "__tmp_port"
          }
          rule {
            action = "labeldrop"
            regex = "__tmp_port"
          }

          rule {
            source_labels = ["__meta_kubernetes_service_annotation_k8s_grafana_com_metrics_scheme"]
            regex = "(.+)"
            target_label = "__scheme__"
          }

          rule {
            source_labels = ["__meta_kubernetes_service_annotation_k8s_grafana_com_metrics_scrapeInterval"]
            regex = "(.+)"
            target_label = "__scrape_interval__"
          }
          rule {
            source_labels = ["__scrape_interval__"]
            regex = ""
            replacement = "60s"
            target_label = "__scrape_interval__"
          }
          rule {
            source_labels = ["__meta_kubernetes_service_annotation_k8s_grafana_com_metrics_scrapeTimeout"]
            regex = "(.+)"
            target_label = "__scrape_timeout__"
          }
          rule {
            source_labels = ["__scrape_timeout__"]
            regex = ""
            replacement = "10s"
            target_label = "__scrape_timeout__"
          }
        }

        discovery.relabel "annotation_autodiscovery_http" {
          targets = concat(discovery.relabel.annotation_autodiscovery_pods.output, discovery.relabel.annotation_autodiscovery_services.output)
          rule {
            source_labels = ["__scheme__"]
            regex = "https"
            action = "drop"
          }
        }

        discovery.relabel "annotation_autodiscovery_https" {
          targets = concat(discovery.relabel.annotation_autodiscovery_pods.output, discovery.relabel.annotation_autodiscovery_services.output)
          rule {
            source_labels = ["__scheme__"]
            regex = "https"
            action = "keep"
          }
        }

        prometheus.scrape "annotation_autodiscovery_http" {
          targets = discovery.relabel.annotation_autodiscovery_http.output
          honor_labels = true
          bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
          clustering {
            enabled = true
          }

          forward_to = argument.metrics_destinations.value
        }

        prometheus.scrape "annotation_autodiscovery_https" {
          targets = discovery.relabel.annotation_autodiscovery_https.output
          honor_labels = true
          bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
          tls_config {
            insecure_skip_verify = true
          }
          clustering {
            enabled = true
          }

          forward_to = argument.metrics_destinations.value
        }
      }
