# yamllint disable rule:document-start rule:line-length rule:trailing-spaces rule:empty-lines
suite: Test default values
templates:
  - configmap.yaml
tests:
  - it: should render the default configuration
    set:
      deployAsConfigMap: true
    asserts:
      - isKind:
          of: ConfigMap
      - equal:
          path: data["module.alloy"]
          value: |-
            declare "pod_logs" {
              argument "logs_destinations" {
                comment = "Must be a list of log destinations where collected logs should be forwarded to"
              }

              discovery.relabel "filtered_pods" {
                targets = discovery.kubernetes.pods.targets
                rule {
                  source_labels = ["__meta_kubernetes_namespace"]
                  action = "replace"
                  target_label = "namespace"
                }
                rule {
                  source_labels = ["__meta_kubernetes_pod_name"]
                  action = "replace"
                  target_label = "pod"
                }
                rule {
                  source_labels = ["__meta_kubernetes_pod_container_name"]
                  action = "replace"
                  target_label = "container"
                }
                rule {
                  source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
                  separator = "/"
                  action = "replace"
                  replacement = "$1"
                  target_label = "job"
                }

                // set the container runtime as a label
                rule {
                  action = "replace"
                  source_labels = ["__meta_kubernetes_pod_container_id"]
                  regex = "^(\\S+):\\/\\/.+$"
                  replacement = "$1"
                  target_label = "tmp_container_runtime"
                }

                // set the job label from the k8s.grafana.com/logs.job annotation if it exists
                rule {
                  source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_logs_job"]
                  regex = "(.+)"
                  target_label = "job"
                }

                // make all labels on the pod available to the pipeline as labels,
                // they are omitted before write to loki via stage.label_keep unless explicitly set
                rule {
                  action = "labelmap"
                  regex = "__meta_kubernetes_pod_label_(.+)"
                }

                // make all annotations on the pod available to the pipeline as labels,
                // they are omitted before write to loki via stage.label_keep unless explicitly set
                rule {
                  action = "labelmap"
                  regex = "__meta_kubernetes_pod_annotation_(.+)"
                }
              }

              discovery.kubernetes "pods" {
                role = "pod"
                selectors {
                  role = "pod"
                  field = "spec.nodeName=" + sys.env("HOSTNAME")
                }
              }

              discovery.relabel "filtered_pods_with_paths" {
                targets = discovery.relabel.filtered_pods.output

                rule {
                  source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
                  separator = "/"
                  action = "replace"
                  replacement = "/var/log/pods/*$1/*.log"
                  target_label = "__path__"
                }
              }

              local.file_match "pod_logs" {
                path_targets = discovery.relabel.filtered_pods_with_paths.output
              }

              loki.source.file "pod_logs" {
                targets    = local.file_match.pod_logs.targets
                forward_to = [loki.process.pod_logs.receiver]
              }

              loki.process "pod_logs" {
                stage.match {
                  selector = "{tmp_container_runtime=~\"containerd|cri-o\"}"
                  // the cri processing stage extracts the following k/v pairs: log, stream, time, flags
                  stage.cri {}

                  // Set the extract flags and stream values as labels
                  stage.labels {
                    values = {
                      flags  = "",
                      stream  = "",
                    }
                  }
                }

                stage.match {
                  selector = "{tmp_container_runtime=\"docker\"}"
                  // the docker processing stage extracts the following k/v pairs: log, stream, time
                  stage.docker {}

                  // Set the extract stream value as a label
                  stage.labels {
                    values = {
                      stream  = "",
                    }
                  }
                }

                // Drop the filename label, since it's not really useful in the context of Kubernetes, where we already have cluster,
                // namespace, pod, and container labels. Drop any structured metadata. Also drop the temporary
                // container runtime label as it is no longer needed.
                stage.label_drop {
                  values = [
                    "filename",
                    "tmp_container_runtime",
                  ]
                }

                // Only keep the labels that are defined in the `keepLabels` list.
                stage.label_keep {
                  values = ["app_kubernetes_io_name","container","instance","job","level","namespace","pod","service_name"]
                }

                forward_to = argument.logs_destinations.value
              }
            }

  - it: should allow overriding the default labelsToKeep
    set:
      deployAsConfigMap: true
      labelsToKeep:
        - k8s_container_name
        - k8s_namespace
        - k8s_pod_name
        - k8s_pod_label_app_kubernetes_io_name
    asserts:
      - isKind:
          of: ConfigMap
      - equal:
          path: data["module.alloy"]
          value: |-
            declare "pod_logs" {
              argument "logs_destinations" {
                comment = "Must be a list of log destinations where collected logs should be forwarded to"
              }

              discovery.relabel "filtered_pods" {
                targets = discovery.kubernetes.pods.targets
                rule {
                  source_labels = ["__meta_kubernetes_namespace"]
                  action = "replace"
                  target_label = "namespace"
                }
                rule {
                  source_labels = ["__meta_kubernetes_pod_name"]
                  action = "replace"
                  target_label = "pod"
                }
                rule {
                  source_labels = ["__meta_kubernetes_pod_container_name"]
                  action = "replace"
                  target_label = "container"
                }
                rule {
                  source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
                  separator = "/"
                  action = "replace"
                  replacement = "$1"
                  target_label = "job"
                }

                // set the container runtime as a label
                rule {
                  action = "replace"
                  source_labels = ["__meta_kubernetes_pod_container_id"]
                  regex = "^(\\S+):\\/\\/.+$"
                  replacement = "$1"
                  target_label = "tmp_container_runtime"
                }

                // set the job label from the k8s.grafana.com/logs.job annotation if it exists
                rule {
                  source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_logs_job"]
                  regex = "(.+)"
                  target_label = "job"
                }

                // make all labels on the pod available to the pipeline as labels,
                // they are omitted before write to loki via stage.label_keep unless explicitly set
                rule {
                  action = "labelmap"
                  regex = "__meta_kubernetes_pod_label_(.+)"
                }

                // make all annotations on the pod available to the pipeline as labels,
                // they are omitted before write to loki via stage.label_keep unless explicitly set
                rule {
                  action = "labelmap"
                  regex = "__meta_kubernetes_pod_annotation_(.+)"
                }
              }

              discovery.kubernetes "pods" {
                role = "pod"
                selectors {
                  role = "pod"
                  field = "spec.nodeName=" + sys.env("HOSTNAME")
                }
              }

              discovery.relabel "filtered_pods_with_paths" {
                targets = discovery.relabel.filtered_pods.output

                rule {
                  source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
                  separator = "/"
                  action = "replace"
                  replacement = "/var/log/pods/*$1/*.log"
                  target_label = "__path__"
                }
              }

              local.file_match "pod_logs" {
                path_targets = discovery.relabel.filtered_pods_with_paths.output
              }

              loki.source.file "pod_logs" {
                targets    = local.file_match.pod_logs.targets
                forward_to = [loki.process.pod_logs.receiver]
              }

              loki.process "pod_logs" {
                stage.match {
                  selector = "{tmp_container_runtime=~\"containerd|cri-o\"}"
                  // the cri processing stage extracts the following k/v pairs: log, stream, time, flags
                  stage.cri {}

                  // Set the extract flags and stream values as labels
                  stage.labels {
                    values = {
                      flags  = "",
                      stream  = "",
                    }
                  }
                }

                stage.match {
                  selector = "{tmp_container_runtime=\"docker\"}"
                  // the docker processing stage extracts the following k/v pairs: log, stream, time
                  stage.docker {}

                  // Set the extract stream value as a label
                  stage.labels {
                    values = {
                      stream  = "",
                    }
                  }
                }

                // Drop the filename label, since it's not really useful in the context of Kubernetes, where we already have cluster,
                // namespace, pod, and container labels. Drop any structured metadata. Also drop the temporary
                // container runtime label as it is no longer needed.
                stage.label_drop {
                  values = [
                    "filename",
                    "tmp_container_runtime",
                  ]
                }

                // Only keep the labels that are defined in the `keepLabels` list.
                stage.label_keep {
                  values = ["k8s_container_name","k8s_namespace","k8s_pod_name","k8s_pod_label_app_kubernetes_io_name"]
                }

                forward_to = argument.logs_destinations.value
              }
            }


  - it: should allow setting structured metadata
    set:
      deployAsConfigMap: true
      structuredMetadata:
        caller: caller
        component: component
    asserts:
      - isKind:
          of: ConfigMap
      - equal:
          path: data["module.alloy"]
          value: |-
            declare "pod_logs" {
              argument "logs_destinations" {
                comment = "Must be a list of log destinations where collected logs should be forwarded to"
              }

              discovery.relabel "filtered_pods" {
                targets = discovery.kubernetes.pods.targets
                rule {
                  source_labels = ["__meta_kubernetes_namespace"]
                  action = "replace"
                  target_label = "namespace"
                }
                rule {
                  source_labels = ["__meta_kubernetes_pod_name"]
                  action = "replace"
                  target_label = "pod"
                }
                rule {
                  source_labels = ["__meta_kubernetes_pod_container_name"]
                  action = "replace"
                  target_label = "container"
                }
                rule {
                  source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
                  separator = "/"
                  action = "replace"
                  replacement = "$1"
                  target_label = "job"
                }

                // set the container runtime as a label
                rule {
                  action = "replace"
                  source_labels = ["__meta_kubernetes_pod_container_id"]
                  regex = "^(\\S+):\\/\\/.+$"
                  replacement = "$1"
                  target_label = "tmp_container_runtime"
                }

                // set the job label from the k8s.grafana.com/logs.job annotation if it exists
                rule {
                  source_labels = ["__meta_kubernetes_pod_annotation_k8s_grafana_com_logs_job"]
                  regex = "(.+)"
                  target_label = "job"
                }

                // make all labels on the pod available to the pipeline as labels,
                // they are omitted before write to loki via stage.label_keep unless explicitly set
                rule {
                  action = "labelmap"
                  regex = "__meta_kubernetes_pod_label_(.+)"
                }

                // make all annotations on the pod available to the pipeline as labels,
                // they are omitted before write to loki via stage.label_keep unless explicitly set
                rule {
                  action = "labelmap"
                  regex = "__meta_kubernetes_pod_annotation_(.+)"
                }
              }

              discovery.kubernetes "pods" {
                role = "pod"
                selectors {
                  role = "pod"
                  field = "spec.nodeName=" + sys.env("HOSTNAME")
                }
              }

              discovery.relabel "filtered_pods_with_paths" {
                targets = discovery.relabel.filtered_pods.output

                rule {
                  source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
                  separator = "/"
                  action = "replace"
                  replacement = "/var/log/pods/*$1/*.log"
                  target_label = "__path__"
                }
              }

              local.file_match "pod_logs" {
                path_targets = discovery.relabel.filtered_pods_with_paths.output
              }

              loki.source.file "pod_logs" {
                targets    = local.file_match.pod_logs.targets
                forward_to = [loki.process.pod_logs.receiver]
              }

              loki.process "pod_logs" {
                stage.match {
                  selector = "{tmp_container_runtime=~\"containerd|cri-o\"}"
                  // the cri processing stage extracts the following k/v pairs: log, stream, time, flags
                  stage.cri {}

                  // Set the extract flags and stream values as labels
                  stage.labels {
                    values = {
                      flags  = "",
                      stream  = "",
                    }
                  }
                }

                stage.match {
                  selector = "{tmp_container_runtime=\"docker\"}"
                  // the docker processing stage extracts the following k/v pairs: log, stream, time
                  stage.docker {}

                  // Set the extract stream value as a label
                  stage.labels {
                    values = {
                      stream  = "",
                    }
                  }
                }

                // Drop the filename label, since it's not really useful in the context of Kubernetes, where we already have cluster,
                // namespace, pod, and container labels. Drop any structured metadata. Also drop the temporary
                // container runtime label as it is no longer needed.
                stage.label_drop {
                  values = [
                    "filename",
                    "tmp_container_runtime",
                  ]
                }
                // set the structured metadata values
                stage.structured_metadata {
                  values = {
                    "caller" = "caller",
                    "component" = "component",
                  }
                }

                // Only keep the labels that are defined in the `keepLabels` list.
                stage.label_keep {
                  values = ["app_kubernetes_io_name","container","instance","job","level","namespace","pod","service_name"]
                }

                forward_to = argument.logs_destinations.value
              }
            }
